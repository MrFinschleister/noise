<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
    <style>
        body {
            margin: 0;
            padding: none;
            background-color: darkslategrey;
            overflow-x: hidden;
            overflow-y: hidden;
        }

        label {
            display: block;
            color: white;
        }

        input {
            display: inline-block;
        }
    </style>
</head>
    <body onload="onload()">
    <div id="gradientsDiv" style="position: absolute; left: 0; padding: 2vh; display: none;">
        <button onclick="addGradient()">Add Gradient</button>
        <label>Depth level: -1 to 1</label>
        <input type="number" id="gradientWeight" value="0">
        <label>R</label>
        <input type="number" id="gradientR" value="255">
        <label>G</label>
        <input type="number" id="gradientG" value="255">
        <label>B</label>
        <input type="number" id="gradientB" value="255">
    </div>

    <div id="optionsDiv" style="position: absolute; right: 0; padding: 2vh; display: none;">
        <button onclick="generateWithSettings()">Generate With Settings</button>
        <label>Width: </label>
        <input type="number" id="width">
        <label>Height: </label>
        <input type="number" id="height">
        <label>Seed: </label>
        <input type="text" id="seed">
        <label>Octaves: </label>
        <input type="number" id="octaves">   
        <label>Cell Size: </label>
        <input type="number" id="cellSize">   
        <label>Frequency: </label>
        <input type="number" id="frequency">
        <label>Factor: </label>
        <input type="number" id="factor">
        <label>Roughness: </label>
        <input type="number" id="roughness">   
        <label>Persistence: </label>
        <input type="number" id="persistence">      
        <label>Contrast: </label>
        <input type="number" id="contrast">    
        <label>Offset X: </label>
        <input type="number" id="offsetX">   
        <label>Offset Y: </label>
        <input type="number" id="offsetY">    
        <label>Tick Time: </label>
        <input type="number" id="tickTime"> 
        <label>Scale: </label>
        <input type="number" id="scale"> 
        <label>Growth Rate: </label>
        <input type="number" id="growthRate"> 
        <label>Decay Rate: </label>
        <input type="number" id="decayRate"> 
        <label>Speed Factor: </label>
        <input type="number" id="speedFactor"> 
        <label>Rebirth Rate: </label>
        <input type="number" id="rebirthRate"> 
        <label>Color Contrast: </label>
        <input type="number" id="colorContrast"> 
        <label>Color Volatility: </label>
        <input type="number" id="colorVolatility"> 
    </div>

    <canvas width="500" height="500" id="canvas" style="width: 100vw; height: 100vh; background-color: rgb(0, 0, 0);" ></canvas>
    
    <script src="perlin.js"></script>
    <script>
        let canvas = document.getElementById('canvas')
        let ctx = canvas.getContext('2d')

        let seed = Math.random() * 100
        let octaves = 2
        let cellSize = 100
        let frequency = 1
        let factor = 1
        let roughness = 3
        let persistence = 0.4
        let contrast = 1.5
        let offsetX = 0
        let offsetY = 0
        let scale = 15
        let tickTime = 10
        let growthRate = 0.25
        let decayRate = 0.05
        let speedFactor = 0.5
        let rebirthRate = 500
        let colorContrast = 10
        let colorVolatility = 0
        let doRebirth = true
        let useRandomness = true
        let editingMode = false

        let noise = new Perlin(seed)
        let interval

        let totalTime = 0
        let numRebirths = 0

        let gradients = [
            {weight: -1, color: [0, 255, 0, 255]},
            {weight: 0, color: [0, 0, 255, 255]},
            {weight: 1, color: [255, 0, 0, 255]},
        ]

        let gradientLookup = {

        }

        let particles = []

        let useClickInfluence = false
        let clickInfluence

        let clickInfluenceRadius = 100
        let clickInfluenceStrength = 1

        class Vector2 {
            constructor(x, y) {
                this.x = x
                this.y = y
            }

            add(v2) {
                this.x += v2.x
                this.y += v2.y
            }

            scale(scalar) {
                this.x *= scalar
                this.y *= scalar
            }

            clone() {
                return new Vector2(this.x, this.y)
            }
        }

        class Particle {
            constructor() {
                this.originalPos = new Vector2(0, 0)
                this.pos = new Vector2(0, 0)
                this.vel = new Vector2(0, 0)
                this.acc = new Vector2(0, 0)
            }

            update() {
                this.wrapped = false

                this.lastPos = this.pos.clone()
                this.vel.add(this.acc)
                this.pos.add(this.vel)
                this.acc.scale(0)

                this.vel.scale(speedFactor)

                this.edges()

                if (!this.wrapped) {
                    this.render()
                }
            }

            edges() {
                if (this.pos.x > canvas.width) {
                    this.pos.x = 0
                    this.wrapped = true
                } else if (this.pos.x < 0) {
                    this.pos.x = canvas.width
                    this.wrapped = true
                }
                if (this.pos.y > canvas.height) {
                    this.pos.y = 0
                    this.wrapped = true
                } else if (this.pos.y < 0) {
                    this.pos.y = canvas.height
                    this.wrapped = true
                }

                if (this.wrapped) {
                    this.vel.scale(0)
                }
            }

            render() {
                ctx.beginPath()
                ctx.moveTo(this.lastPos.x, this.lastPos.y)
                ctx.lineTo(this.pos.x, this.pos.y)
                ctx.stroke()
            }

            applyForce(force) {
                this.acc.add(force)
            }
        }

        function interpolateRGBA(color1, color2, weight) {
            let r3 = color1[0] + (color2[0] - color1[0]) * weight
            let g3 = color1[1] + (color2[1] - color1[1]) * weight
            let b3 = color1[2] + (color2[2] - color1[2]) * weight
            let a3 = color1[3] + (color2[3] - color1[3]) * weight

            return [r3, g3, b3, a3]
        }

        function lerp(val1, val2, weight) {
            return val1 + (val2 - val1) * weight
        }

        function generateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            particles = []

            for (let x = 0; x < canvas.width / scale; x++) {
                for (let y = 0; y < canvas.height / scale; y++) {
                    let sel = new Particle()

                    sel.originalPos.x = x * scale
                    sel.originalPos.y = y * scale

                    sel.pos = sel.originalPos.clone()

                    particles.push(sel)
                }
            }
        }

        function beginInterval() {
            totalTime = 0
            numRebirths = 0

            if (interval) {
                clearInterval(interval)
            }
            
            interval = setInterval(function() {
                tick()
            }, tickTime)
        }

        function tick() {
            if (totalTime % rebirthRate == 0 && doRebirth && useRandomness) {
                randomiseStuff()
                numRebirths++
            }

            if (numRebirths > 10) {
                ctx.clearRect(0, 0, canvas.width, canvas.height )
            }

            totalTime += 1

            ctx.globalAlpha = decayRate
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillRect(0, 0, canvas.width, canvas.height)
            ctx.globalAlpha = 1

            updateParticles()

            let data = ctx.getImageData(0, 0, canvas.width, canvas.height).data

            ctx.putImageData(new ImageData(data, canvas.width), 0, 0)
        }

        function updateParticles() {
            for (let x = 0; x < particles.length; x++) {
                let sel = particles[x]

                let val = noise.perlinLayered(sel.pos.x, sel.pos.y, octaves, cellSize, frequency, factor, roughness, persistence, contrast)

                if (val < -1) {
                    val = -1
                } else if (val > 1) {
                    val = 1
                }

                let colorVal = val.toFixed(1)

                let finalColor = gradientLookup[colorVal] ? gradientLookup[colorVal] : addGradientLookup(colorVal)

                ctx.strokeStyle = "rgba(" + finalColor[0] + ", " + finalColor[1] + ", " + finalColor[2] + ", " + growthRate + ")"

                let force = new Vector2(Math.cos(val * Math.PI), Math.sin(val * Math.PI))
                force.scale(speedFactor)
                
                if (useClickInfluence) {
                    let distanceX = clickInfluence.x - sel.pos.x
                    let distanceY = clickInfluence.y - sel.pos.y
                    let distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY)

                    if (distance < clickInfluenceRadius && distanceX != 0 && distanceY != 0) {
                        let force1 = new Vector2(distanceX / distance, distanceY / distance)
                        force1.scale(clickInfluenceStrength)

                        force.add(force1)
                    }
                }

                sel.applyForce(force)
                sel.update()
            }
        }

        function addGradientLookup(colorVal) {
            let color1 = [0, 0, 0, 0]
            let color2 = [0, 0, 0, 0]

            let weight = 0

            let colorIndex = 0

            while (colorVal > gradients[colorIndex].weight) {
                colorIndex++
            }

            color1 = gradients[colorIndex - 1].color
            color2 = gradients[colorIndex].color

            weight = (gradients[colorIndex - 1].weight - colorVal) / (gradients[colorIndex - 1].weight - gradients[colorIndex].weight)

            let finalColor = interpolateRGBA(color1, color2, Math.pow(weight, 0.75))

            gradientLookup[colorVal] = finalColor

            return finalColor
        }

        function setupGradientLookup() {
            gradientLookup = {"-1.0": gradients[0], "1.0": gradients[gradients.length - 1]}

            for (let x = -1; x <= 1; x += 0.1) {
                if (gradientLookup[x.toFixed(1)]) {
                    continue
                }
                
                addGradientLookup(x.toFixed(1))
            }
        }

        function randomiseStuff() {
            for (let x = 0; x < particles.length; x++) {
                particles[x].pos = particles[x].originalPos.clone()
                particles[x].vel.scale(0)
            }

            let contrastRange = [1, 2]
            let octavesRange = [1, 4]
            let roughnessRange = [1, 8]
            let persistenceRange = [0, 1]
            let cellSizeRange = [100, 500]
            let colorContrastRange = [1, 15]
            let speedFactorRange = [0.25, 0.5]
            
            noise = new Perlin(Math.random() * 100)
            contrast = Math.random() * (contrastRange[1] - contrastRange[0]) + contrastRange[0]
            octaves = Math.round(Math.random() * (octavesRange[1] - octavesRange[0])) + octavesRange[0]
            roughness = Math.round(Math.random() * (roughnessRange[1] - roughnessRange[0])) + roughnessRange[0]
            persistence = Math.random() * (persistenceRange[1] - persistenceRange[0]) + persistenceRange[0]
            cellSize = Math.round(Math.random() * (cellSizeRange[1] - cellSizeRange[0])) + cellSizeRange[1]
            colorContrast = Math.random() * (colorContrastRange[1] - colorContrastRange[0]) + colorContrastRange[0]
            speedFactor = Math.random() * (speedFactorRange[1] - speedFactorRange[0]) + speedFactorRange[1]

            for (let x = 0; x < gradients.length; x++) {
                for (let y = 0; y < gradients[x].color.length - 1; y++) {
                    gradients[x].color[y] *= 1 + (Math.random() * colorVolatility * 2) - colorVolatility
                }
            }

            setupGradientLookup()
            updateData()
        }
        
        function addGradient() {
            let newGradient = {}

            newGradient.weight = document.getElementById('gradientWeight').value
            newGradient.color = []
            newGradient.color[0] = document.getElementById('gradientR').value
            newGradient.color[1] = document.getElementById('gradientG').value
            newGradient.color[2] = document.getElementById('gradientB').value
            newGradient.color[3] = 255

            gradients.push(newGradient)
        }

        function generateWithSettings() {
            canvas.width = document.getElementById('width').value
            canvas.height = document.getElementById('height').value
            seed = document.getElementById('seed').value
            octaves = document.getElementById('octaves').value
            cellSize = document.getElementById('cellSize').value
            frequency = document.getElementById('frequency').value
            factor = document.getElementById('factor').value
            roughness = document.getElementById('roughness').value
            persistence = document.getElementById('persistence').value
            contrast = document.getElementById('contrast').value
            offsetX = document.getElementById('offsetX').value
            offsetY = document.getElementById('offsetY').value
            tickTime = document.getElementById('tickTime').value
            scale = document.getElementById('scale').value
            growthRate = document.getElementById('growthRate').value
            decayRate = document.getElementById('decayRate').value
            speedFactor = document.getElementById('speedFactor').value
            rebirthRate = document.getElementById('rebirthRate').value
            colorContrast = document.getElementById('colorContrast').value
            colorVolatility = document.getElementById('colorVolatility').value

            setup()
        }

        function updateData() {
            document.getElementById('width').value = canvas.width
            document.getElementById('height').value = canvas.height
            document.getElementById('seed').value = seed
            document.getElementById('octaves').value = octaves
            document.getElementById('cellSize').value = cellSize
            document.getElementById('frequency').value = frequency
            document.getElementById('factor').value = factor
            document.getElementById('roughness').value = roughness
            document.getElementById('persistence').value = persistence
            document.getElementById('contrast').value = contrast
            document.getElementById('offsetX').value = offsetX
            document.getElementById('offsetY').value = offsetY
            document.getElementById('tickTime').value = tickTime
            document.getElementById('scale').value = scale
            document.getElementById('growthRate').value = growthRate
            document.getElementById('decayRate').value = decayRate
            document.getElementById('speedFactor').value = speedFactor
            document.getElementById('rebirthRate').value = rebirthRate
            document.getElementById('colorContrast').value = colorContrast
            document.getElementById('colorVolatility').value = colorVolatility
        }

        function onload() {
            try {
                canvas.width = canvas.clientWidth
                canvas.height = canvas.clientHeight
                document.addEventListener('mousedown', mousedown)
                document.addEventListener('touchstart', touchstart)
                document.addEventListener('keydown', keydown)
     
                setup()
            } catch (error) {
                alert(error)
            }
        }

        function setup() {
            if (editingMode) {
                document.getElementById('gradientsDiv').style.display = "inline"
                document.getElementById('optionsDiv').style.display = "inline"
            }

            setupGradientLookup()
            updateData()
            generateParticles()
            beginInterval()
        }

        function keydown(e) {
            if (e.key == "Enter") {
                totalTime = 0
            } else if (e.key == "Shift") {
                doRebirth = !doRebirth
            }
        }
        
        function mousedown(e) {
            useClickInfluence = true
            clickInfluence = new Vector2(e.offsetX, e.offsetY)
            document.addEventListener('mousemove', mousemove)
            document.addEventListener('mouseup', mouseup)
        }

        function mousemove(e) {
            clickInfluence = new Vector2(e.offsetX, e.offsetY)
        }

        function mouseup(e) {
            useClickInfluence = false
            document.removeEventListener('mousemove', mousemove)
            document.removeEventListener('mouseup', mouseup)
        }

        function touchstart(e) {
            useClickInfluence = true
            clickInfluence = new Vector2(e.touches[0].clientX, e.touches[0].clientY)

            document.addEventListener('touchend', touchend)
            document.addEventListener('touchmove', touchmove)
        }

        function touchmove(e) {
            clickInfluence = new Vector2(e.touches[0].clientX, e.touches[0].clientY)
        }

        function touchend(e) {
            useClickInfluence = false
            document.removeEventListener('touchmove', touchmove)
            document.removeEventListener('touchend', touchend)
        }
    </script>
</body>
</html>