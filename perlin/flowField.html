<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
    <style>
        body {
            margin: 0;
            padding: none;
            background-color: darkslategrey;
            overflow-x: hidden;
            overflow-y: hidden;
        }

        label {
            display: block;
            color: white;
        }

        input {
            display: inline-block;
        }
    </style>
</head>
<body onload="onload()">
    <p id="fps" style="position: absolute; color: white; width: 5vw; height: 2vw; margin: 2vh;"></p>
    <div id="gradientsDiv" style="position: absolute; left: 0; padding: 2vh; display: none;">
        <button onclick="addGradient()">Add Gradient</button>
        <label>Depth level: -1 to 1</label>
        <input type="number" id="gradientWeight" value="0">
        <label>R</label>
        <input type="number" id="gradientR" value="255">
        <label>G</label>
        <input type="number" id="gradientG" value="255">
        <label>B</label>
        <input type="number" id="gradientB" value="255">
    </div>

    <div id="optionsDiv" style="position: absolute; right: 0; padding: 2vh; display: none;">
        <button onclick="generateWithSettings()">Generate With Settings</button>
        <label>Width: </label>
        <input type="number" id="width">
        <label>Height: </label>
        <input type="number" id="height">
        <label>Seed: </label>
        <input type="text" id="seed">
        <label>Octaves: </label>
        <input type="number" id="octaves">   
        <label>Cell Size: </label>
        <input type="number" id="cellSize">   
        <label>Frequency: </label>
        <input type="number" id="frequency">
        <label>Factor: </label>
        <input type="number" id="factor">
        <label>Roughness: </label>
        <input type="number" id="roughness">   
        <label>Persistence: </label>
        <input type="number" id="persistence">      
        <label>Contrast: </label>
        <input type="number" id="contrast">    
        <label>Offset X: </label>
        <input type="number" id="offsetX">   
        <label>Offset Y: </label>
        <input type="number" id="offsetY">    
        <label>Tick Time: </label>
        <input type="number" id="tickTime"> 
        <label>Scale: </label>
        <input type="number" id="scale"> 
        <label>Growth Rate: </label>
        <input type="number" id="growthRate"> 
        <label>Decay Rate: </label>
        <input type="number" id="decayRate"> 
        <label>Speed Factor: </label>
        <input type="number" id="speedFactor"> 
        <label>Rebirth Rate: </label>
        <input type="number" id="rebirthRate"> 
        <label>Color Contrast: </label>
        <input type="number" id="colorContrast"> 
        <label>Color Volatility: </label>
        <input type="number" id="colorVolatility"> 
    </div>

    <canvas width="500" height="500" id="canvas" style="width: 100vw; height: 100vh; background-color: rgb(0, 0, 0);" ></canvas>
    
    <script src="perlin.js"></script>
    <script>
        let canvas = document.getElementById('canvas')
        let ctx = canvas.getContext('2d')

        let seed = Math.random() * 100
        let octaves = 2
        let cellSize = 100
        let frequency = 1
        let factor = 1
        let roughness = 3
        let persistence = 0.4
        let contrast = 1.5
        let offsetX = 0
        let offsetY = 0
        let scale = 15
        let tickTime = 10
        let growthRate = 0.9
        let decayRate = 0.05
        let speedFactor = 0.5
        let rebirthRate = 1000
        let colorContrast = 10
        let colorVolatility = 0
        let doRebirth = true
        let useRandomness = true
        let editingMode = false

        let perlin
        let interval

        let totalTicks = 0
        let numRebirths = 0

        let gradients = [
            {weight: -1, color: [255, 0, 0, 255]},
            {weight: 0, color: [255, 0, 255, 255]},
            {weight: 1, color: [0, 0, 255, 255]},
        ]

        let gradientLookup = {

        }

        let particles = []

        let useClickInfluence = false
        let clickX = 0
        let clickY = 0
        let clickInfluenceRadius = 50
        let clickInfluenceStrength = 0.01

        let returnHomePercent = 0.8
        let returnHomeWeight = 0

        class Vector2 {
            constructor(x, y) {
                this.x = x
                this.y = y
            }

            add(v2) {
                this.x += v2.x
                this.y += v2.y
            }

            scale(scalar) {
                this.x *= scalar
                this.y *= scalar
            }

            clone() {
                return new Vector2(this.x, this.y)
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x
                this.y = y

                this.originalX = x
                this.originalY = y

                this.velX = 0
                this.velY = 0
            }

            update() {
                this.velX *= speedFactor
                this.velY *= speedFactor

                this.x += this.velX
                this.y += this.velY
            }
        }

        function interpolateRGBA(color1, color2, weight) {
            let r3 = color1[0] + (color2[0] - color1[0]) * weight
            let g3 = color1[1] + (color2[1] - color1[1]) * weight
            let b3 = color1[2] + (color2[2] - color1[2]) * weight
            let a3 = color1[3] + (color2[3] - color1[3]) * weight

            return [r3, g3, b3, a3]
        }

        function lerp(val1, val2, weight) {
            return val1 + (val2 - val1) * weight
        }

        function ease(t) {
            let t3 = t * t * t
            let t4 = t3 * t
            let t5 = t4 * t
            return 6 * t5 - 15 * t4 + 10 * t3
        }

        function generateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            particles = []

            for (let x = 0; x < canvas.width / scale; x++) {
                for (let y = 0; y < canvas.height / scale; y++) {
                    let sel = new Particle(x * scale, y * scale)

                    particles.push(sel)
                }
            }
        }

        function beginInterval() {
            totalTicks = 0
            numRebirths = 0

            if (interval) {
                clearInterval(interval)
            }
            
            interval = setInterval(function() {
                tick()
            }, tickTime)
        }

        function tick() {
            if (totalTicks % rebirthRate == 0 && doRebirth && useRandomness) {
                randomiseStuff()
                numRebirths++

                for (let x = 0; x < particles.length; x++) {
                    let x1 = particles[x].x
                    let y1 = particles[x].y
                    let oX = particles[x].originalX
                    let oY = particles[x].originalY

                    if (Math.abs(x1 - oX) > 50 || Math.abs(y1 - oY) > 50) {
                        particles[x].x = oX
                        particles[x].y = oY
                    }
                }
            }

            ctx.fillStyle = "rgba(0, 0, 0, " + decayRate + ")"
            ctx.fillRect(0, 0, canvas.width, canvas.height)

            updateParticles()
            totalTicks += 1
        }

        function updateParticles() {
            let percentageComplete = (totalTicks % rebirthRate) / rebirthRate

            let opacity = percentageComplete > returnHomePercent ? growthRate / 2 : growthRate

            for (let x = 0; x < particles.length; x++) {
                let sel = particles[x]

                let val = perlin.perlinLayered(sel.x, sel.y)

                if (val < -1) {
                    val = -1
                } else if (val > 1) {
                    val = 1
                }

                let colorVal = val.toFixed(1)

                let finalColor = gradientLookup[colorVal] ? gradientLookup[colorVal] : addGradientLookup(colorVal)
                ctx.strokeStyle = "rgba(" + finalColor[0] + ", " + finalColor[1] + ", " + finalColor[2] + ", " + growthRate + ")"

                let forceX = Math.cos(val * Math.PI) * speedFactor
                let forceY = Math.sin(val * Math.PI) * speedFactor

                if (useClickInfluence) {
                    let dX = clickX - sel.x
                    let dY = clickY - sel.y

                    let distance = Math.sqrt(dX * dX + dY * dY)

                    if (distance <= clickInfluenceRadius && distance != 0) {
                        forceX += dX / distance * clickInfluenceStrength
                        forceY += dY / distance * clickInfluenceStrength
                    }
                }

                if (percentageComplete > returnHomePercent) {
                    let dX = sel.originalX - sel.x
                    let dY = sel.originalY - sel.y

                    if (Math.abs(dX) > canvas.width / 2) {
                        dX *= -1
                    }

                    if (Math.abs(dY) > canvas.height / 2) {
                        dY *= -1
                    }

                    let distance = Math.sqrt(dX * dX + dY * dY)

                    if (distance != 0) {
                        forceX += dX / distance * returnHomeWeight / percentageComplete
                        forceY += dY / distance * returnHomeWeight / percentageComplete
                    }                    
                }

                sel.velX += forceX
                sel.velY += forceY

                let oldX = sel.x
                let oldY = sel.y

                sel.update()

                let wrapped = true

                if (sel.x < 0) {
                    sel.x = canvas.width
                    wrapped = false
                } else if (sel.x > canvas.width) {
                    sel.x = 0
                    wrapped = false
                }
                
                if (sel.y < 0) {
                    sel.y = canvas.height
                    wrapped = false
                } else if (sel.y > canvas.height) {
                    sel.y = 0
                    wrapped = false
                }
                
                if (wrapped) {
                    ctx.beginPath()
                    ctx.moveTo(oldX, oldY)
                    ctx.lineTo(sel.x, sel.y)
                    ctx.stroke()
                }
            }
        }

        function addGradientLookup(colorVal) {
            let color1 = [0, 0, 0, 0]
            let color2 = [0, 0, 0, 0]

            let weight = 0

            let colorIndex = 0

            while (colorVal > gradients[colorIndex].weight) {
                colorIndex++
            }

            color1 = gradients[colorIndex - 1].color
            color2 = gradients[colorIndex].color

            weight = (gradients[colorIndex - 1].weight - colorVal) / (gradients[colorIndex - 1].weight - gradients[colorIndex].weight)

            let finalColor = interpolateRGBA(color1, color2, Math.pow(weight, 0.75))

            gradientLookup[colorVal] = finalColor

            return finalColor
        }

        function setupGradientLookup() {
            gradients.sort((a, b) => a.weight - b.weight)

            gradients[0].weight = -1
            gradients[gradients.length - 1].weight = 1

            gradientLookup = {"-1.0": gradients[0], "1.0": gradients[gradients.length - 1]}

            for (let x = -1; x <= 1; x += 0.1) {
                if (gradientLookup[x.toFixed(1)]) {
                    continue
                }
                
                addGradientLookup(x.toFixed(1))
            }
        }

        function randomiseStuff() {
            let contrastRange = [1, 2]
            let octavesRange = [1, 4]
            let roughnessRange = [1, 8]
            let persistenceRange = [0, 1]
            let cellSizeRange = [100, 500]
            let colorContrastRange = [10, 15]
            let speedFactorRange = [0.4, 0.65]
            
            seed = Math.random() * 100
            contrast = randRange(contrastRange)
            octaves = Math.round(randRange(octavesRange))
            roughness = Math.round(randRange(roughnessRange))
            persistence = randRange(persistenceRange)
            cellSize = Math.round(randRange(cellSizeRange))
            colorContrast = randRange(colorContrastRange)
            speedFactor = randRange(speedFactorRange)

            setPerlin()
            setupGradientLookup()
            updateData()
        }

        function randRange(range) {
            return (Math.random() * (range[1] - range[0])) + range[0]
        }

        function setPerlin() {
            perlin = new Perlin(seed)

            perlin.octaves = octaves
            perlin.cellSize = cellSize
            perlin.frequency = frequency
            perlin.factor = factor
            perlin.roughness = roughness
            perlin.persistence = persistence
            perlin.contrast = contrast
        }
        
        function addGradient() {
            let newGradient = {}

            newGradient.weight = document.getElementById('gradientWeight').value
            newGradient.color = []
            newGradient.color[0] = document.getElementById('gradientR').value
            newGradient.color[1] = document.getElementById('gradientG').value
            newGradient.color[2] = document.getElementById('gradientB').value
            newGradient.color[3] = 255

            gradients.push(newGradient)
        }

        function generateWithSettings() {
            canvas.width = document.getElementById('width').value
            canvas.height = document.getElementById('height').value
            seed = document.getElementById('seed').value
            octaves = document.getElementById('octaves').value
            cellSize = document.getElementById('cellSize').value
            frequency = document.getElementById('frequency').value
            factor = document.getElementById('factor').value
            roughness = document.getElementById('roughness').value
            persistence = document.getElementById('persistence').value
            contrast = document.getElementById('contrast').value
            offsetX = document.getElementById('offsetX').value
            offsetY = document.getElementById('offsetY').value
            tickTime = document.getElementById('tickTime').value
            scale = document.getElementById('scale').value
            growthRate = document.getElementById('growthRate').value
            decayRate = document.getElementById('decayRate').value
            speedFactor = document.getElementById('speedFactor').value
            rebirthRate = document.getElementById('rebirthRate').value
            colorContrast = document.getElementById('colorContrast').value
            colorVolatility = document.getElementById('colorVolatility').value

            setup()
        }

        function updateData() {
            document.getElementById('width').value = canvas.width
            document.getElementById('height').value = canvas.height
            document.getElementById('seed').value = seed
            document.getElementById('octaves').value = octaves
            document.getElementById('cellSize').value = cellSize
            document.getElementById('frequency').value = frequency
            document.getElementById('factor').value = factor
            document.getElementById('roughness').value = roughness
            document.getElementById('persistence').value = persistence
            document.getElementById('contrast').value = contrast
            document.getElementById('offsetX').value = offsetX
            document.getElementById('offsetY').value = offsetY
            document.getElementById('tickTime').value = tickTime
            document.getElementById('scale').value = scale
            document.getElementById('growthRate').value = growthRate
            document.getElementById('decayRate').value = decayRate
            document.getElementById('speedFactor').value = speedFactor
            document.getElementById('rebirthRate').value = rebirthRate
            document.getElementById('colorContrast').value = colorContrast
            document.getElementById('colorVolatility').value = colorVolatility
        }

        function onload() {
            try {
                canvas.width = canvas.clientWidth
                canvas.height = canvas.clientHeight
                document.addEventListener('mousedown', mousedown)
                document.addEventListener('touchstart', touchstart)
                document.addEventListener('keydown', keydown)
     
                setup()
            } catch (error) {
                alert(error.stack)
            }
        }

        function setup() {
            if (editingMode) {
                document.getElementById('gradientsDiv').style.display = "inline"
                document.getElementById('optionsDiv').style.display = "inline"
            }

            setupGradientLookup()
            updateData()
            generateParticles()
            setPerlin()
            beginInterval()
        }

        function keydown(e) {
            if (e.key == "Enter") {
                totalTicks = 0
            } else if (e.key == "Shift") {
                doRebirth = !doRebirth
            }
        }
        
        function mousedown(e) {
            useClickInfluence = true
            clickX = e.clientX
            clickY = e.clientY
            document.addEventListener('mousemove', mousemove)
            document.addEventListener('mouseup', mouseup)
        }

        function mousemove(e) {
            clickX = e.clientX
            clickY = e.clientY
        }

        function mouseup(e) {
            useClickInfluence = false
            document.removeEventListener('mousemove', mousemove)
            document.removeEventListener('mouseup', mouseup)
        }

        function touchstart(e) {
            useClickInfluence = true
            clickX = e.touches[0].clientX
            clickY = e.touches[0].clientY

            document.addEventListener('touchend', touchend)
            document.addEventListener('touchmove', touchmove)
        }

        function touchmove(e) {
            clickX = e.touches[0].clientX
            clickY = e.touches[0].clientY
        }

        function touchend(e) {
            useClickInfluence = false
            document.removeEventListener('touchmove', touchmove)
            document.removeEventListener('touchend', touchend)
        }
    </script>
</body>
</html>