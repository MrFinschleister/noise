<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
    <style>
        body {
            margin: 0;
            padding: none;
            background-color: darkslategrey;
            overflow-x: hidden;
            overflow-y: hidden;
        }

        label {
            display: block;
            color: white;
        }

        input {
            display: inline-block;
        }
    </style>
</head>
    <body onload="onload()"><div id="colorGradientsDiv" style="position: absolute; left: 0; padding: 2vh">
        <button onclick="addGradient()">Add Gradient</button>
        <label>Depth level: -1 to 1</label>
        <input type="number" id="gradientWeight" value="0">
        <label>R</label>
        <input type="number" id="gradientR" value="255">
        <label>G</label>
        <input type="number" id="gradientG" value="255">
        <label>B</label>
        <input type="number" id="gradientB" value="255">
    </div>

    <div id="optionsDiv" style="position: absolute; right: 0; padding: 2vh;">
        <button onclick="generateWithSettings()">Generate With Settings</button>
        <label>Width: </label>
        <input type="number" id="width">
        <label>Height: </label>
        <input type="number" id="height">
        <label>Seed: </label>
        <input type="text" id="seed">
        <label>Octaves: </label>
        <input type="number" id="octaves">   
        <label>Cell Size: </label>
        <input type="number" id="cellSize">   
        <label>Frequency: </label>
        <input type="number" id="frequency">
        <label>Factor: </label>
        <input type="number" id="factor">
        <label>Roughness: </label>
        <input type="number" id="roughness">   
        <label>Persistence: </label>
        <input type="number" id="persistence">      
        <label>Contrast: </label>
        <input type="number" id="contrast">    
        <label>Offset X: </label>
        <input type="number" id="offsetX">   
        <label>Offset Y: </label>
        <input type="number" id="offsetY">    
        <label>Tick Time: </label>
        <input type="number" id="tickTime"> 
        <label>Scale: </label>
        <input type="number" id="scale"> 
        <label>Growth Rate: </label>
        <input type="number" id="growthRate"> 
        <label>Decay Rate: </label>
        <input type="number" id="decayRate"> 
        <label>Speed Factor: </label>
        <input type="number" id="speedFactor"> 
        <label>Rebirth Rate: </label>
        <input type="number" id="rebirthRate"> 
        <label>Color Contrast: </label>
        <input type="number" id="colorContrast"> 
        <label>Color Volatility: </label>
        <input type="number" id="colorVolatility"> 
    </div>

    <canvas width="500" height="500" id="canvas" style="width: 100vw; height: 100vh; background-color: rgb(0, 0, 0);" ></canvas>
    
    <script src="perlin.js"></script>
    <script>
        let canvas = document.getElementById('canvas')
        let ctx = canvas.getContext('2d')

        let seed = Math.random() * 100
        let octaves = 2
        let cellSize = 100
        let frequency = 1
        let factor = 1
        let roughness = 3
        let persistence = 0.4
        let contrast = 1.5
        let offsetX = 0
        let offsetY = 0
        let scale = 15
        let tickTime = 10
        let growthRate = 0.1
        let decayRate = 0.05
        let speedFactor = 0.01
        let rebirthRate = 500
        let colorContrast = 10
        let colorVolatility = 0

        class Vector2 {
            constructor(x, y) {
                this.x = x
                this.y = y
            }

            add(v2) {
                this.x += v2.x
                this.y += v2.y
            }

            scale(scalar) {
                this.x *= scalar
                this.y *= scalar
            }

            clone() {
                return new Vector2(this.x, this.y)
            }
        }

        class Particle {
            constructor() {
                this.originalPos = new Vector2(0, 0)
                this.pos = new Vector2(0, 0)
                this.vel = new Vector2(0, 0)
                this.acc = new Vector2(0, 0)
            }

            update() {
                if (totalTime % rebirthRate == 0) {
                    this.pos = this.originalPos.clone()
		    this.vel.scale(0)
                }

                this.wrapped = false

                this.lastPos = this.pos.clone()
                this.vel.add(this.acc)
                this.pos.add(this.vel)
                this.acc.scale(0)

                this.edges()

                if (!this.wrapped) {
                    this.render()
                }

                this.vel.scale(speedFactor)
            }

            edges() {
                if (this.pos.x > canvas.width) {
                    this.pos.x = 0
                    this.wrapped = true
                } else if (this.pos.x < 0) {
                    this.pos.x = canvas.width
                    this.wrapped = true
                }
                if (this.pos.y > canvas.height) {
                    this.pos.y = 0
                    this.wrapped = true
                } else if (this.pos.y < 0) {
                    this.pos.y = canvas.height
                    this.wrapped = true
                }

                if (this.wrapped) {
                    this.vel.scale(0)
                }
            }

            render() {
                ctx.beginPath()
                ctx.moveTo(this.lastPos.x, this.lastPos.y)
                ctx.lineTo(this.pos.x, this.pos.y)
                ctx.stroke()
            }

            applyForce(force) {
                this.acc.add(force)
            }
        }

        let gradients = [
            {weight: -1, color: [0, 255, 0, 255]},
            {weight: 0, color: [0, 0, 255, 255]},
            {weight: 1, color: [255, 0, 0, 255]},
        ]

        let lookup = {
            "-1": [0, 0, 128, 255],
            "1": {weight: 1, color: [255, 255, 255, 255]},
        }

        function interpolateRGBA(color1, color2, weight) {
            let r3 = color1[0] + (color2[0] - color1[0]) * weight
            let g3 = color1[1] + (color2[1] - color1[1]) * weight
            let b3 = color1[2] + (color2[2] - color1[2]) * weight
            let a3 = color1[3] + (color2[3] - color1[3]) * weight

            return [r3, g3, b3, a3]
        }

        let particles = []

        let noise
        let interval

        let totalTime

        function generateNoise() {
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            noise = new Perlin(seed)
            totalTime = 0
            
            if (interval) {
                clearInterval(interval)
            }

            particles = []

            for (let x = 0; x < canvas.width / scale; x++) {
                for (let y = 0; y < canvas.height / scale; y++) {
                    let sel = new Particle()

                    sel.originalPos.x = x * scale
                    sel.originalPos.y = y * scale

                    sel.pos = sel.originalPos.clone()

                    particles.push(sel)
                }
            }

            interval = setInterval(function() {
                updateParticles()
            }, tickTime)
        }

        function lerp(val1, val2, weight) {
            return val1 + (val2 - val1) * weight
        }

        function smooth(t) {
            let t3 = t * t * t
            let t4 = t3 * t
            let t5 = t4 * t
            return 6 * t5 - 15 * t4 + 10 * t3
        }

        function updateParticles() {
            ctx.globalAlpha = decayRate * smooth((rebirthRate - totalTime) / rebirthRate)
            ctx.fillStyle = "rgb(0, 0, 0)"
            ctx.fillRect(0, 0, canvas.width, canvas.height)
            ctx.globalAlpha = 1
            
            for (let x = 0; x < particles.length; x++) {
                let sel = particles[x]

                let val = noise.perlinLayered(sel.pos.x, sel.pos.y, octaves, cellSize, frequency, factor, roughness, persistence, contrast)

                if (val < -1) {
                    val = -1
                } else if (val > 1) {
                    val = 1
                }

                let colorVal = Math.round(val * 100) / 100

                let finalColor

                if (lookup[colorVal]) {
                    finalColor = lookup[colorVal]
                } else {
                    let color1 = [0, 0, 0, 0]
                    let color2 = [0, 0, 0, 0]

                    let weight = 0

                    let colorIndex = 0

                    while (colorVal > gradients[colorIndex].weight) {
                        colorIndex++
                    }

                    color1 = gradients[colorIndex - 1].color
                    color2 = gradients[colorIndex].color

                    weight = (gradients[colorIndex - 1].weight - colorVal) / (gradients[colorIndex - 1].weight - gradients[colorIndex].weight)

                    finalColor = interpolateRGBA(color1, color2, weight ** 0.75)

                    lookup[colorVal] = finalColor
                }

                val = (val + 1) / 2

                ctx.strokeStyle = "rgba(" + finalColor[0] + ", " + finalColor[1] + ", " + finalColor[2] + ", " + growthRate + ")"

                let force = new Vector2(Math.cos(val * Math.PI * 2), Math.sin(val * Math.PI * 2))

                sel.applyForce(force)
                sel.update()
            }

            if (totalTime % rebirthRate == 0) {
                totalTime = 0
                noise = new Perlin(Math.floor(Math.random() * 100))
		        contrast = Math.random() * 1 + 1
                octaves = Math.floor(Math.random() * 7) + 1
                roughness = Math.floor(Math.random() * 7) + 1
                persistence = Math.random() * 1
                cellSize = Math.floor(Math.random() * 500) + 100
                colorContrast = Math.random() * 15
		        speedFactor = Math.random() * 0.1 + 0.01

                for (let x = 0; x < gradients.length; x++) {
                    for (let y = 0; y < gradients[x].color.length - 1; y++) {
                        gradients[x].color[y] *= 1 + (Math.random() * colorVolatility * 2) - colorVolatility
                    }
                }

                lookup = {"-1": gradients[0], "1": gradients[gradients.length - 1]}
            }

            totalTime += 1
        }
        
        function addGradient() {
            let newGradient = {}

            newGradient.weight = document.getElementById('gradientWeight').value
            newGradient.color = []
            newGradient.color[0] = document.getElementById('gradientR').value
            newGradient.color[1] = document.getElementById('gradientG').value
            newGradient.color[2] = document.getElementById('gradientB').value
            newGradient.color[3] = 255

            gradients.push(newGradient)
        }

        function generateWithSettings() {
            canvas.width = document.getElementById('width').value
            canvas.height = document.getElementById('height').value
            seed = document.getElementById('seed').value
            octaves = document.getElementById('octaves').value
            cellSize = document.getElementById('cellSize').value
            frequency = document.getElementById('frequency').value
            factor = document.getElementById('factor').value
            roughness = document.getElementById('roughness').value
            persistence = document.getElementById('persistence').value
            contrast = document.getElementById('contrast').value
            offsetX = document.getElementById('offsetX').value
            offsetY = document.getElementById('offsetY').value
            tickTime = document.getElementById('tickTime').value
            scale = document.getElementById('scale').value
            growthRate = document.getElementById('growthRate').value
            decayRate = document.getElementById('decayRate').value
            speedFactor = document.getElementById('speedFactor').value
            rebirthRate = document.getElementById('rebirthRate').value
            colorContrast = document.getElementById('colorContrast').value
            colorVolatility = document.getElementById('colorVolatility').value

            generateNoise()
        }

        function onload() {
            try {
                canvas.width = canvas.clientWidth
                canvas.height = canvas.clientHeight

                document.getElementById('width').value = canvas.width
                document.getElementById('height').value = canvas.height
                document.getElementById('seed').value = seed
                document.getElementById('octaves').value = octaves
                document.getElementById('cellSize').value = cellSize
                document.getElementById('frequency').value = frequency
                document.getElementById('factor').value = factor
                document.getElementById('roughness').value = roughness
                document.getElementById('persistence').value = persistence
                document.getElementById('contrast').value = contrast
                document.getElementById('offsetX').value = offsetX
                document.getElementById('offsetY').value = offsetY
                document.getElementById('tickTime').value = tickTime
                document.getElementById('scale').value = scale
                document.getElementById('growthRate').value = growthRate
                document.getElementById('decayRate').value = decayRate
                document.getElementById('speedFactor').value = speedFactor
                document.getElementById('rebirthRate').value = rebirthRate
                document.getElementById('colorContrast').value = colorContrast
                document.getElementById('colorVolatility').value = colorVolatility

                generateNoise()                
            } catch (error) {
                alert(error)
            }
        }
    </script>
</body>
</html>
